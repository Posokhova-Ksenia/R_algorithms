#Задано N городов c номерами от 1 до N и сеть из M дорог с односторонним движением между ними. Каждая дорога задается тройкой (i, j, k), где i - номер города, в котором дорога начинается, j -номер города, в котором дорога заканчивается, а k - ее длина (число k - натуральное). Дороги друг с другом могут пересекаться только в концевых городах.
#Все пути между двумя указанными городами A и B можно упорядочить в список по неубыванию их длин (если есть несколько путей одинаковой длины, то выбираем один из них). Необходимо найти один из путей, который может быть вторым в списке.
#Алгоритм:
  
 # 1. С помощью алгоритма Дейкстры находим кратчайший (первый минимальный) путь между начальным пунктом и конечным,состоящий из дорог(рёбер) s1,..,sn.
#2. Второй кратчайший путь не будет содержать хотя бы одно ребро из s_i, следовательно алгоритм нахождения второго пути будет следующим:
#Для i от 1 до n
#Берем ребро si из первого мин. пути и удаляем его из графа.
#Находим кратчайший путь в новом графе, запоминаем его как минимальный.
#Если найденный путь оказался меньше минимального, то запомним текущий путь и его длину
#Восстанавливаем ребро si и делаем ту же самую процедуру для si+1



m<-matrix(0, nrow =4, ncol = 4)
m[1,]<-c(0, Inf,1,5)
m[2,]<-c(Inf,0,Inf,1)
m[3,]<-c(Inf,1,0,3)
m[4,]<-c(Inf,Inf,Inf,0)

Mn<- function(R,A){
  min<- Inf
  nmin<-"нет вершин" 
  for( i in 1: length(A)){
    if((R[i]<min)&(A[i] == 0)){
      min<-R[i]
      nmin<-i
    }
  }
  return(nmin)
}


#проверки
check_mat<-function(m){
  
  if (is.matrix(m)==FALSE){
    stop("необходимо ввести матрицу")
  }
  if(nrow(m)!= ncol(m)){
    stop("матрица должна быть квадратной")
  }
  if (is.numeric(m)==FALSE){
    stop("необходимо ввести числовые значения")
  }
} 
if(any(m<0)){
  stop("убери отрицательные веса")
}


Dijkstra<- function(v1,v2,m){
  
  n<-nrow(m)
  check_mat(m)
  otvetik<-list()
  
  if (is.numeric(v1)==FALSE){
    stop("необходимо ввести числовые значения v1")
  }
  if (is.numeric(v2)==FALSE){
    stop("необходимо ввести числовые значения v2")
  }
  if((v1 %in% 1:n)==FALSE){
    stop('такой вершины v1 не существует в графе')
  }
  if((v2 %in% 1:n)==FALSE){
    stop('такой вершины v2 не существует в графе')
  }
  if(v1==v2){
    stop("пути не существует")
  }
  
  R<-m[v1,]                                                        
  A<-rep(0 , n)                                                     # появляется так как по массиву R теперь не понятно, прошли мы вершину или нет (когда все А ==1, то все вершины пройдены)
  A[v1]<-1
  #массив предков 
  P<-rep(0 , n)                                                     #нужен нам для поиска маршрута, мы должны знать, из чего сложился путь 
  P[(R>0) & (R!=Inf)]<-v1
  
  while(sum(A) != length(A)){
    k<- Mn(R,A)                                                     #та вершина, через которую мы хотим научиться ходить
    if(k=="нет вершин") {break()}
    for (i in 1:n){                                                 #смотрим все вершины
      if(R[i]>(R[k]+m[k,i])){                                       #то что у нас есть оно лучше или хуже того, как мы можем научиться ходить через к вершину
        R[i] <- R[k] + m[k,i]                                         #меняем веса
        P[i]<-k
      }
      A[k]<-1
    }
    
  }
  #путь
  if(P[v2]!=0){                                                    #проверка можем ли дойти (можно было и через R проверить)
    road<-v2
    if(P[v2]==P[v1]){
      road<-c(v1,v2)
    }else{
      while (P[v2]!= v1){
        P[v2]<-P[road[1]]
        road<-c(P[v2], road)
      }
    }
  }else{
    road<-Inf
  }
  
  

  otvetik<- list( length = R[v2], road=road)
  return(otvetik)
}
Dijkstra(1,4,m)

r<-(unlist(Dijkstra(1,4,m)[2]))
print(r[1])




LQ<-function(m){
  
  min_2<- +Inf
  min_2_road<-0
for (i in 1:(length(r)-1)) {
  
  m_2<-m
  m_2[r[i],r[i+1]]<-Inf
  m_2[r[i+1],r[i]]<-Inf
  print( m_2)
  
  Dijkstra(1,4,m_2)
  l<-unlist(Dijkstra(1,4,m_2)[1])
  if (l<min_2) {
    min_2<-l 
    min_2_road<-unlist(Dijkstra(1,4,m_2) [2] )
  }
}
if (min_2==Inf) {print("Пути нет")
} else {cat("Путь проходит через города  ", min_2_road,"  ","Длина пути",min_2) }
}

LQ(m)















