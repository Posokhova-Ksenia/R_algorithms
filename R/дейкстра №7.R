library(igraph)
#задаем матрицу
set.seed(5)

m<-matrix(0, nrow =4, ncol = 4)
m[1,]<-c(0, Inf,1,5)
m[2,]<-c(Inf,0,Inf,1)
m[3,]<-c(Inf,1,0,3)
m[4,]<-c(Inf,Inf,Inf,0)

#рисуем матрицу

g<-m
g[g==Inf]<-0
a<-graph.adjacency(g, mode ="directed", weighted = T)
#plot.igraph(a, edge.label=c(t(g)[t(g)!=0]),
            #edge.arrow.size =0.5, layout=layout_in_circle)

plot.igraph(a,edge.label=c(t(g)[t(g)!=0]), edge.arrow.size=0.5)




#большая матрица, с которой мы работаем (файл на флешке)

file <- 'E:/dijkstra/dijkstraData.csv'
t <- read.csv(file, sep=' ')
n<- length(t[,1])
m <- matrix(c(rep(0, n*n)), nrow=n, byrow = T)
for (i in 1:n){
  for (j in 1:n){
    m[i,j]<- t[i,j]
  }
}





#находит минимальное значение в массиве R и смотрит на то значение, которое в массиве А обозначено 0
#"нет вершин" - индикатор, когда начальное значение не меняется, алгоритм можно заканчивать 

Mn<- function(R,A){
  min<- Inf
  nmin<-"нет вершин" 
  for( i in 1: length(A)){
    if((R[i]<min)&(A[i] == 0)){
      min<-R[i]
      nmin<-i
    }
  }
  return(nmin)
}


#проверки
check_mat<-function(m){
  
  if (is.matrix(m)==FALSE){
    stop("необходимо ввести матрицу")
  }
  if(nrow(m)!= ncol(m)){
    stop("матрица должна быть квадратной")
  }
  if (is.numeric(m)==FALSE){
    stop("необходимо ввести числовые значения")
  }
} 
  if(any(m<0)){
    stop("убери отрицательные веса")
  }
  

Dijkstra<- function(v1,v2,m){
  
  n<-nrow(m)
  check_mat(m)
  otvetik<-list()
  
  if (is.numeric(v1)==FALSE){
    stop("необходимо ввести числовые значения v1")
  }
  if (is.numeric(v2)==FALSE){
    stop("необходимо ввести числовые значения v2")
  }
  if((v1 %in% 1:n)==FALSE){
    stop('такой вершины v1 не существует в графе')
  }
  if((v2 %in% 1:n)==FALSE){
    stop('такой вершины v2 не существует в графе')
  }
  if(v1==v2){
    stop("пути не существует")
  }

R<-m[v1,]                                                         #строка той вершины, из которой мы начинаем                                                       
A<-rep(0 , n)                                                     # появляется так как по массиву R теперь не понятно, прошли мы вершину или нет (когда все А ==1, то все вершины пройдены)
A[v1]<-1 
#массив предков 
P<-rep(0 , n)                                                     #нужен нам для поиска маршрута, мы должны знать, из чего сложился путь 
P[(R>0) & (R!=Inf)]<-v1                                           #мы первой вершиной заполняем те, в которые умеем ходить из первой ( например на месте 3 и 4 вершины будет 1)

while(sum(A) != length(A)){
  k<- Mn(R,A)                                                     #та вершина, через которую мы хотим научиться ходить
if(k=="нет вершин") {break()}
 for (i in 1:n){                                                 #смотрим все вершины
   if(R[i]>(R[k]+m[k,i])){                                       #то что у нас есть оно лучше или хуже того, как мы можем научиться ходить через к вершину
    R[i] <- R[k] + m[k,i]                                         #меняем веса
    P[i]<-k
   }
   A[k]<-1
 }
  
}
#путь 
if(P[v2]!=0){                                                    #проверка можем ли дойти (можно было и через R проверить)
  road<-v2
  if(P[v2]==v1){                                                #если мы из последней сразу можем попасть в первую, то все круто !
    road<-c(v1,v2)
  }else{
    while (P[v2]!= v1){                                         #обратная раскрутка алгоритма
      P[v2]<-P[road[1]]
      road<-c(P[v2], road)
    }
  }
}else{
  road<-Inf
}



otvetik<- list( length = R[v2], road=road)
return(otvetik)
}
 
Dijkstra(1,4,m)

  #функция поиска столицы в графе (вершины, от которой можно дойти до всех других вершин за наименьшее расстояние)
stol<-function(m){
  n<-nrow(m)
  min_R<-Inf
  for(i in 1:n){
    v1<-i
    R<-m[v1,]                                                        
    A<-rep(0 , n)                                                     # появляется так как по массиву R теперь не понятно, прошли мы вершину или нет (когда все А ==1, то все вершины пройдены)
    A[v1]<-1
    #массив предков 
    P<-rep(0 , n)                                                     #нужен нам для поиска маршрута, мы должны знать, из чего сложился путь 
    P[(R>0) & (R!=Inf)]<-v1
    
    while(sum(A) != length(A)){
      k<- Mn(R,A)                                                     #та вершина, через которую мы хотим научиться ходить
      if(k=="нет вершин") {break()}
      for (j in 1:n){                                                 #смотрим все вершины
        if(R[j]>(R[k]+m[k,j])){                                       #то что у нас есть оно лучше или хуже того, как мы можем научиться ходить через к вершину
          R[j] <- R[k] + m[k,j]                                         #меняем веса
          P[j]<-k
        }
        A[k]<-1
      }
    }
    if (sum(R)< sum(min_R)){
      min_R <- R
      min_v <- i
    }
  }
  return(list(min_v, min_R))
  }
test1 <- stol(m)
test1









































